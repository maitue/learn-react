import { css } from 'goober';
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';

const defaultStrings = {
  allItemsAreSelected: "All items are selected.",
  clearSearch: "Clear Search",
  clearSelected: "Clear Selected",
  noOptions: "No options",
  search: "Search",
  selectAll: "Select All",
  selectSomeItems: "Select..."
};
const defaultProps = {
  value: [],
  focusSearchOnOpen: true,
  hasSelectAll: true,
  className: "multi-select",
  debounceDuration: 200,
  options: []
};
const MultiSelectContext = /*#__PURE__*/React.createContext({});
const MultiSelectProvider = ({
  props,
  children
}) => {
  const t = key => {
    var _props$overrideString;

    return ((_props$overrideString = props.overrideStrings) == null ? void 0 : _props$overrideString[key]) || defaultStrings[key];
  };

  return React.createElement(MultiSelectContext.Provider, {
    value: {
      t,
      ...defaultProps,
      ...props
    }
  }, children);
};
const useMultiSelect = () => React.useContext(MultiSelectContext);

/**
 * combines classNames in a friendly way
 *
 * @param {*} classes
 */
const cn = (...classes) => classes.join(" ");

/**
 * similar to `useEffect` but gets triggered only when value changes
 * @param fn executable function on dependency updates
 * @param inputs dependency array
 */

function useDidUpdateEffect(fn, inputs) {
  const didMountRef = useRef(false);
  useEffect(() => {
    if (didMountRef.current) fn();else didMountRef.current = true;
  }, inputs);
}

const debounce = (func, wait) => {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(null, args);
    }, wait);
  };
};

/**
 * Filters React Select options and sorts by similarity to a search filter.
 * Handles partial matches, eg. searching for "Waberg High" will find "Raoul
 * Wallenberg Traditional High School". Case insensitive. Ignores
 * non-alphanumeric characters.
 *
 * @param  options  An unfiltered list of Options.
 * @param? filter  A string to compare against Option labels.
 * @param? substitutions  Strings with multiple spellings or variations that we
 *           expect to match, eg. accented characters or abbreviated words.
 *
 * @return A filtered and sorted array of Options.
 */
function filterOptions(options, filter, substitutions) {
  // If the filter is blank, return the full list of Options.
  if (!filter) {
    return options;
  }

  const cleanFilter = cleanUpText(filter, substitutions);
  return options // Filter out undefined or null Options.
  .filter(({
    label,
    value
  }) => label != null && value != null) // Create a {score, Option} pair for each Option based on its label's
  // similarity to the filter text.
  .map(option => ({
    option: option,
    score: typeaheadSimilarity(cleanUpText(option.label, substitutions), cleanFilter)
  })) // Only include matches of the entire substring, with a slight
  // affordance for transposition or extra characters.
  .filter(pair => pair.score >= cleanFilter.length - 2) // Sort 'em by order of their score.
  .sort((a, b) => b.score - a.score) // …and grab the original Options back from their pairs.
  .map(pair => pair.option);
}
/**
 * Scores the similarity between two strings by returning the length of the
 * longest common subsequence. Intended for comparing strings of different
 * lengths; eg. when matching a typeahead search input with a school name.

 * Meant for use in an instant search box where results are being fetched
 * as a user is typing.
 *
 * @param  a  The longer string (though, we flip them if it's shorter).
 * @param  b  The shorter string, eg. a typeahead search input.
 *
 * @return The length of the longest common subsequence. Higher scores indicate
 *           closer matches.
 */

function typeaheadSimilarity(a, b) {
  const aLength = a.length;
  const bLength = b.length;
  const table = [];

  if (!aLength || !bLength) {
    return 0;
  } // Ensure `a` isn't shorter than `b`.


  if (aLength < bLength) {
    [a, b] = [b, a];
  } // Early exit if `a` includes `b`; these will be scored higher than any
  // other options with the same `b` (filter string), with a preference for
  // shorter `a` strings (option labels).


  if (a.indexOf(b) !== -1) {
    return bLength + 1 / aLength;
  } // Initialize the table axes:
  //
  //    0 0 0 0 ... bLength
  //    0
  //    0
  //
  //   ...
  //
  // aLength
  //


  for (let x = 0; x <= aLength; ++x) {
    table[x] = [0];
  }

  for (let y = 0; y <= bLength; ++y) {
    table[0][y] = 0;
  } // Populate the rest of the table with a dynamic programming algorithm.


  for (let x = 1; x <= aLength; ++x) {
    for (let y = 1; y <= bLength; ++y) {
      table[x][y] = a[x - 1] === b[y - 1] ? 1 + table[x - 1][y - 1] : Math.max(table[x][y - 1], table[x - 1][y]);
    }
  }

  return table[aLength][bLength];
}
/**
 * Apply string substitutions, remove non-alphanumeric characters, and convert
 * all letters to uppercase.
 *
 * eg. 'Scoil Bhríde Primary School' may become 'SCOILBHRIDEPRIMARYSCHOOL'.
 *
 * @param  input  An unsanitized input string.
 * @param  substitutions  Strings with multiple spellings or variations that we
 *          expect to match, for example accented characters or abbreviated
 *          words.
 *
 * @return The sanitized text.
 */

function cleanUpText(input, substitutions) {
  if (!input) {
    return "";
  } // Uppercase and remove all non-alphanumeric, non-accented characters.
  // Also remove underscores.


  input = input.toUpperCase().replace(/((?=[^\u00E0-\u00FC])\W)|_/g, "");

  if (!substitutions) {
    return input;
  }

  const safeSubstitutions = substitutions; // For Flow.
  // Replace all strings in `safeSubstitutions` with their standardized
  // counterparts.

  return Object.keys(safeSubstitutions).reduce((output, substitution) => {
    const unsubbed = new RegExp(substitution, "g");
    return output.replace(unsubbed, safeSubstitutions[substitution]);
  }, input);
}

const Cross = () => React.createElement("svg", {
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  className: "dropdown-search-clear-icon gray"
}, React.createElement("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}), React.createElement("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
}));

const DefaultRenderer = /*#__PURE__*/css({
  "& input,& span": {
    verticalAlign: "middle",
    margin: 0
  },
  span: {
    display: "inline-block",
    paddingLeft: "5px"
  },
  "&.disabled": {
    opacity: 0.5
  }
});

const DefaultItemRenderer = ({
  checked,
  option,
  onClick,
  disabled
}) => React.createElement("div", {
  className: cn(DefaultRenderer, "item-renderer", disabled && "disabled")
}, React.createElement("input", {
  type: "checkbox",
  onChange: onClick,
  checked: checked,
  tabIndex: -1,
  disabled: disabled
}), React.createElement("span", null, option.label));

/**
 * This component represents an individual item in the multi-select drop-down
 */
const ItemContainer = /*#__PURE__*/css({
  boxSizing: "border-box",
  cursor: "pointer",
  display: "block",
  padding: "var(--rmsc-p)",
  outline: 0,
  "&:hover,&:focus": {
    background: "var(--rmsc-hover)"
  },
  "&.selected": {
    background: "var(--rmsc-selected)"
  }
});

const SelectItem = ({
  itemRenderer: ItemRenderer = DefaultItemRenderer,
  option,
  checked,
  focused,
  tabIndex,
  disabled,
  onSelectionChanged,
  onClick
}) => {
  const itemRef = useRef();
  useEffect(() => {
    updateFocus(); // eslint-disable-next-line
  }, [checked, focused]);

  const toggleChecked = () => {
    onSelectionChanged(!checked);
  };

  const handleClick = e => {
    toggleChecked();
    onClick(e);
  };

  const updateFocus = () => {
    if (focused && !disabled && itemRef) {
      itemRef.current.focus();
    }
  };

  const handleKeyDown = e => {
    switch (e.which) {
      case 13: // Enter

      case 32:
        // Space
        toggleChecked();
        break;

      default:
        return;
    }

    e.preventDefault();
  };

  return React.createElement("label", {
    className: cn(ItemContainer, "select-item", checked && "selected"),
    role: "option",
    "aria-selected": checked,
    tabIndex: tabIndex,
    ref: itemRef,
    onKeyDown: handleKeyDown
  }, React.createElement(ItemRenderer, {
    option: option,
    checked: checked,
    onClick: handleClick,
    disabled: disabled
  }));
};

/**
 * This component represents an unadorned list of SelectItem (s).
 */
const SelectListUl = /*#__PURE__*/css({
  margin: 0,
  paddingLeft: 0,
  li: {
    listStyle: "none",
    margin: 0
  }
});
const skipIndex = 2;

const SelectList = ({
  options,
  focusIndex,
  onClick
}) => {
  const {
    disabled,
    value,
    onChange,
    ItemRenderer
  } = useMultiSelect();

  const handleSelectionChanged = (option, checked) => {
    if (disabled) {
      return;
    }

    onChange(checked ? [...value, option] : value.filter(o => o.value !== option.value));
  };

  return React.createElement("ul", {
    className: SelectListUl
  }, options.map((o, i) => {
    const tabIndex = i + skipIndex;
    return React.createElement("li", {
      key: (o == null ? void 0 : o.key) || i
    }, React.createElement(SelectItem, {
      focused: focusIndex === tabIndex,
      tabIndex: tabIndex,
      option: o,
      onSelectionChanged: c => handleSelectionChanged(o, c),
      checked: value.find(s => s.value === o.value) ? true : false,
      onClick: e => onClick(e, tabIndex),
      itemRenderer: ItemRenderer,
      disabled: o.disabled || disabled
    }));
  }));
};

/**
 * This component represents the entire panel which gets dropped down when the
 * user selects the component.  It encapsulates the search filter, the
 * Select-all item, and the list of options.
 */
var FocusType;

(function (FocusType) {
  FocusType[FocusType["SEARCH"] = -1] = "SEARCH";
  FocusType[FocusType["NONE"] = 1] = "NONE";
})(FocusType || (FocusType = {}));

const SelectSearchContainer = /*#__PURE__*/css({
  width: "100%",
  position: "relative",
  borderBottom: "1px solid var(--rmsc-border)",
  input: {
    height: "var(--rmsc-h)",
    padding: "0 var(--rmsc-p)",
    width: "100%",
    outline: 0,
    border: 0
  }
});
const SearchClearButton = /*#__PURE__*/css({
  cursor: "pointer",
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  background: "none",
  border: 0,
  padding: "0 calc(var(--rmsc-p)/2)",
  "[hidden]": {
    display: "none"
  }
});
const NoOptions = /*#__PURE__*/css({
  padding: "var(--rmsc-p)",
  textAlign: "center",
  color: "var(--rmsc-gray)"
});

const SelectPanel = () => {
  const {
    t,
    onChange,
    options,
    value,
    filterOptions: customFilterOptions,
    selectAllLabel,
    ItemRenderer,
    disabled,
    disableSearch,
    focusSearchOnOpen,
    hasSelectAll,
    ClearIcon,
    debounceDuration
  } = useMultiSelect();
  const searchInputRef = useRef();
  const [searchText, setSearchText] = useState("");
  const [filteredOptions, setFilteredOptions] = useState(options);
  const [searchTextForFilter, setSearchTextForFilter] = useState("");
  const [focusIndex, setFocusIndex] = useState(focusSearchOnOpen && !disableSearch ? FocusType.SEARCH : FocusType.NONE);
  const debouncedSearch = useCallback(debounce(query => setSearchTextForFilter(query), debounceDuration), []);
  const selectAllOption = {
    label: selectAllLabel || t("selectAll"),
    value: ""
  };

  const selectAllValues = checked => {
    const filteredValues = filteredOptions.filter(o => !o.disabled).map(o => o.value);

    if (checked) {
      const selectedValues = value.map(o => o.value);
      const finalSelectedValues = [...selectedValues, ...filteredValues];
      return filteredOptions.filter(o => finalSelectedValues.includes(o.value));
    }

    return value.filter(o => !filteredValues.includes(o.value));
  };

  const selectAllChanged = checked => {
    const newOptions = selectAllValues(checked);
    onChange(newOptions);
  };

  const handleSearchChange = e => {
    debouncedSearch(e.target.value);
    setSearchText(e.target.value);
    setFocusIndex(FocusType.SEARCH);
  };

  const handleClear = () => {
    var _searchInputRef$curre;

    setSearchTextForFilter("");
    setSearchText("");
    searchInputRef == null ? void 0 : (_searchInputRef$curre = searchInputRef.current) == null ? void 0 : _searchInputRef$curre.focus();
  };

  const handleItemClicked = index => setFocusIndex(index);

  const handleKeyDown = e => {
    switch (e.which) {
      case 38:
        // Up Arrow
        if (e.altKey) {
          return;
        }

        updateFocus(-1);
        break;

      case 40:
        // Down Arrow
        if (e.altKey) {
          return;
        }

        updateFocus(1);
        break;

      default:
        return;
    }

    e.stopPropagation();
    e.preventDefault();
  };

  const handleSearchFocus = () => {
    setFocusIndex(FocusType.SEARCH);
  };

  const getFilteredOptions = async () => customFilterOptions ? await customFilterOptions(options, searchTextForFilter) : filterOptions(options, searchTextForFilter);

  const updateFocus = offset => {
    let newFocus = focusIndex + offset;
    newFocus = Math.max(1, newFocus);
    newFocus = Math.min(newFocus, options.length + 1);
    setFocusIndex(newFocus);
  };

  const [isAllOptionSelected, hasSelectableOptions] = useMemo(() => {
    const filteredOptionsList = filteredOptions.filter(o => !o.disabled);
    return [filteredOptionsList.every(o => value.findIndex(v => v.value === o.value) !== -1), filteredOptionsList.length !== 0]; // eslint-disable-next-line
  }, [filteredOptions, value]);
  useEffect(() => {
    getFilteredOptions().then(setFilteredOptions);
  }, [searchTextForFilter, options]);
  return React.createElement("div", {
    className: "select-panel",
    role: "listbox",
    onKeyDown: handleKeyDown
  }, !disableSearch && React.createElement("div", {
    className: SelectSearchContainer
  }, React.createElement("input", {
    autoFocus: focusSearchOnOpen,
    placeholder: t("search"),
    type: "text",
    "aria-describedby": t("search"),
    onKeyDown: e => e.stopPropagation(),
    onChange: handleSearchChange,
    onFocus: handleSearchFocus,
    value: searchText,
    ref: searchInputRef
  }), React.createElement("button", {
    type: "button",
    className: cn(SearchClearButton, "search-clear-button"),
    hidden: !searchText,
    onClick: handleClear,
    "aria-label": t("clearSearch")
  }, ClearIcon || React.createElement(Cross, null))), hasSelectAll && hasSelectableOptions && React.createElement(SelectItem, {
    focused: focusIndex === 1,
    tabIndex: 1,
    checked: isAllOptionSelected,
    option: selectAllOption,
    onSelectionChanged: selectAllChanged,
    onClick: () => handleItemClicked(1),
    itemRenderer: ItemRenderer,
    disabled: disabled
  }), filteredOptions.length ? React.createElement(SelectList, {
    options: filteredOptions,
    focusIndex: focusIndex,
    onClick: (_e, index) => handleItemClicked(index)
  }) : React.createElement("div", {
    className: cn(NoOptions, "no-options")
  }, t("noOptions")));
};

const Arrow = ({
  expanded
}) => React.createElement("svg", {
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  className: "dropdown-heading-dropdown-arrow gray"
}, React.createElement("path", {
  d: expanded ? "M18 15 12 9 6 15" : "M6 9L12 15 18 9"
}));

const DropdownHeader = () => {
  const {
    t,
    value,
    options,
    valueRenderer
  } = useMultiSelect();
  const noneSelected = value.length === 0;
  const allSelected = value.length === options.length;
  const customText = valueRenderer && valueRenderer(value, options);

  const getSelectedText = () => value.map(s => s.label).join(", ");

  return noneSelected ? React.createElement("span", {
    className: "gray"
  }, customText || t("selectSomeItems")) : React.createElement("span", null, customText || (allSelected ? t("allItemsAreSelected") : getSelectedText()));
};

const Spinner = /*#__PURE__*/css({
  animation: "rotate 2s linear infinite",
  "& .path": {
    stroke: "var(--rmsc-border)",
    strokeWidth: "4px",
    strokeLinecap: "round",
    animation: "dash 1.5s ease-in-out infinite"
  },
  "@keyframes rotate": {
    "100%": {
      transform: "rotate(360deg)"
    }
  },
  "@keyframes dash": {
    "0%": {
      strokeDasharray: "1,150",
      strokeDashoffset: 0
    },
    "50%": {
      strokeDasharray: "90,150",
      strokeDashoffset: "-35"
    },
    "100%": {
      strokeDasharray: "90,150",
      strokeDashoffset: "-124"
    }
  }
});
const Loading = ({
  size = 24
}) => React.createElement("span", {
  style: {
    width: size,
    marginRight: "0.2rem"
  }
}, React.createElement("svg", {
  width: size,
  height: size,
  className: Spinner,
  viewBox: "0 0 50 50",
  style: {
    display: "inline",
    verticalAlign: "middle"
  }
}, React.createElement("circle", {
  cx: "25",
  cy: "25",
  r: "20",
  fill: "none",
  className: "path"
})));

/**
 * A generic dropdown component.  It takes the children of the component
 * and hosts it in the component.  When the component is selected, it
 * drops-down the contentComponent and applies the contentProps.
 */
const PanelContainer = /*#__PURE__*/css({
  position: "absolute",
  zIndex: 1,
  top: "100%",
  width: "100%",
  paddingTop: "8px",
  ".panel-content": {
    maxHeight: "300px",
    overflowY: "auto",
    borderRadius: "var(--rmsc-radius)",
    background: "var(--rmsc-bg)",
    boxShadow: "0 0 0 1px rgba(0, 0, 0, 0.1), 0 4px 11px rgba(0, 0, 0, 0.1)"
  }
});
const DropdownContainer = /*#__PURE__*/css({
  position: "relative",
  outline: 0,
  backgroundColor: "var(--rmsc-bg)",
  border: "1px solid var(--rmsc-border)",
  borderRadius: "var(--rmsc-radius)",
  "&:focus-within": {
    boxShadow: "var(--rmsc-main) 0 0 0 1px",
    borderColor: "var(--rmsc-main)"
  }
});
const DropdownHeading = /*#__PURE__*/css({
  position: "relative",
  padding: "0 var(--rmsc-p)",
  display: "flex",
  alignItems: "center",
  width: "100%",
  height: "var(--rmsc-h)",
  cursor: "default",
  outline: 0,
  ".dropdown-heading-value": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    flex: 1
  }
});
const ClearSelectedButton = /*#__PURE__*/css({
  cursor: "pointer",
  background: "none",
  border: 0,
  padding: 0,
  display: "flex"
});

const Dropdown = () => {
  const {
    t,
    onMenuToggle,
    ArrowRenderer,
    shouldToggleOnHover,
    isLoading,
    disabled,
    onChange,
    labelledBy,
    value,
    isOpen,
    defaultIsOpen,
    ClearSelectedIcon
  } = useMultiSelect();
  const [isInternalExpand, setIsInternalExpand] = useState(true);
  const [expanded, setExpanded] = useState(defaultIsOpen);
  const [hasFocus, setHasFocus] = useState(false);
  const FinalArrow = ArrowRenderer || Arrow;
  const wrapper = useRef();
  useDidUpdateEffect(() => {
    onMenuToggle && onMenuToggle(expanded);
  }, [expanded]);
  useEffect(() => {
    if (defaultIsOpen === undefined && typeof isOpen === "boolean") {
      setIsInternalExpand(false);
      setExpanded(isOpen);
    }
  }, [isOpen]);

  const handleKeyDown = e => {
    var _wrapper$current;

    if (isInternalExpand) {
      switch (e.which) {
        case 27: // Escape

        case 38:
          // Up Arrow
          setExpanded(false);
          wrapper == null ? void 0 : (_wrapper$current = wrapper.current) == null ? void 0 : _wrapper$current.focus();
          break;

        case 32: // Space

        case 13: // Enter Key

        case 40:
          // Down Arrow
          setExpanded(true);
          break;

        default:
          return;
      }
    }

    e.preventDefault();
  };

  const handleHover = iexpanded => {
    isInternalExpand && shouldToggleOnHover && setExpanded(iexpanded);
  };

  const handleFocus = () => !hasFocus && setHasFocus(true);

  const handleBlur = e => {
    if (!e.currentTarget.contains(e.relatedTarget) && isInternalExpand) {
      setHasFocus(false);
      setExpanded(false);
    }
  };

  const handleMouseEnter = () => handleHover(true);

  const handleMouseLeave = () => handleHover(false);

  const toggleExpanded = () => {
    isInternalExpand && setExpanded(isLoading || disabled ? false : !expanded);
  };

  const handleClearSelected = e => {
    e.stopPropagation();
    onChange([]);
    isInternalExpand && setExpanded(false);
  };

  return React.createElement("div", {
    tabIndex: 0,
    className: cn(DropdownContainer, "dropdown-container"),
    "aria-labelledby": labelledBy,
    "aria-expanded": expanded,
    "aria-readonly": true,
    "aria-disabled": disabled,
    ref: wrapper,
    onKeyDown: handleKeyDown,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, React.createElement("div", {
    className: cn(DropdownHeading, "dropdown-heading"),
    onClick: toggleExpanded
  }, React.createElement("div", {
    className: "dropdown-heading-value"
  }, React.createElement(DropdownHeader, null)), isLoading && React.createElement(Loading, null), value.length > 0 && React.createElement("button", {
    type: "button",
    className: cn(ClearSelectedButton, "clear-selected-button"),
    onClick: handleClearSelected,
    disabled: disabled,
    "aria-label": t("clearSelected")
  }, ClearSelectedIcon || React.createElement(Cross, null)), React.createElement(FinalArrow, {
    expanded: expanded
  })), expanded && React.createElement("div", {
    className: cn(PanelContainer, "dropdown-content")
  }, React.createElement("div", {
    className: "panel-content"
  }, React.createElement(SelectPanel, null))));
};

const MultiSelectBox = /*#__PURE__*/css({
  "--rmscMain": "#4285f4",
  "--rmscHover": "#f1f3f5",
  "--rmscSelected": "#e2e6ea",
  "--rmscBorder": "#ccc",
  "--rmscGray": "#aaa",
  "--rmscBg": "#fff",
  "--rmscP": "10px",
  "--rmscRadius": "4px",
  "--rmscH": "38px",
  "*": {
    boxSizing: "border-box",
    transition: "all 0.2s ease"
  },
  ".gray": {
    color: "var(--rmsc-gray)"
  }
});

const MultiSelect = props => React.createElement(MultiSelectProvider, {
  props: props
}, React.createElement("div", {
  className: cn(MultiSelectBox, props.className || "multi-select")
}, React.createElement(Dropdown, null)));

export default MultiSelect;
export { Dropdown, SelectItem, SelectPanel };
//# sourceMappingURL=react-multi-select-component.esm.js.map
