(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SVGInjector = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var cloneSvg = function cloneSvg(sourceSvg) {
      return sourceSvg.cloneNode(true);
    };

    /*!
     * content-type
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
     *
     * parameter     = token "=" ( token / quoted-string )
     * token         = 1*tchar
     * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
     *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
     *               / DIGIT / ALPHA
     *               ; any VCHAR, except delimiters
     * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
     * obs-text      = %x80-FF
     * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
     */
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;

    /**
     * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
     *
     * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
     * obs-text    = %x80-FF
     */
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;

    /**
     * RegExp to match type in RFC 7231 sec 3.1.1.1
     *
     * media-type = type "/" subtype
     * type       = token
     * subtype    = token
     */
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var parse_1 = parse;

    /**
     * Parse media type to object.
     *
     * @param {string|object} string
     * @return {Object}
     * @public
     */

    function parse (string) {
      if (!string) {
        throw new TypeError('argument string is required')
      }

      // support req/res-like objects as argument
      var header = typeof string === 'object'
        ? getcontenttype(string)
        : string;

      if (typeof header !== 'string') {
        throw new TypeError('argument string is required to be a string')
      }

      var index = header.indexOf(';');
      var type = index !== -1
        ? header.substr(0, index).trim()
        : header.trim();

      if (!TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid media type')
      }

      var obj = new ContentType(type.toLowerCase());

      // parse parameters
      if (index !== -1) {
        var key;
        var match;
        var value;

        PARAM_REGEXP.lastIndex = index;

        while ((match = PARAM_REGEXP.exec(header))) {
          if (match.index !== index) {
            throw new TypeError('invalid parameter format')
          }

          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];

          if (value[0] === '"') {
            // remove quotes and escapes
            value = value
              .substr(1, value.length - 2)
              .replace(QESC_REGEXP, '$1');
          }

          obj.parameters[key] = value;
        }

        if (index !== header.length) {
          throw new TypeError('invalid parameter format')
        }
      }

      return obj
    }

    /**
     * Get content-type from req/res objects.
     *
     * @param {object}
     * @return {Object}
     * @private
     */

    function getcontenttype (obj) {
      var header;

      if (typeof obj.getHeader === 'function') {
        // res-like
        header = obj.getHeader('content-type');
      } else if (typeof obj.headers === 'object') {
        // req-like
        header = obj.headers && obj.headers['content-type'];
      }

      if (typeof header !== 'string') {
        throw new TypeError('content-type header is missing from object')
      }

      return header
    }

    /**
     * Class to represent a content type.
     * @private
     */
    function ContentType (type) {
      this.parameters = Object.create(null);
      this.type = type;
    }

    var isLocal = function isLocal() {
      return window.location.protocol === 'file:';
    };

    var makeAjaxRequest = function makeAjaxRequest(url, callback) {
      var httpRequest = new XMLHttpRequest();

      httpRequest.onreadystatechange = function () {
        try {
          if (!/\.svg/i.test(url) && httpRequest.readyState === 2) {
            var contentType = httpRequest.getResponseHeader('Content-Type');

            if (!contentType) {
              throw new Error('Content type not found');
            }

            var type = parse_1(contentType).type;

            if (!(type === 'image/svg+xml' || type === 'text/plain')) {
              throw new Error("Invalid content type: " + type);
            }
          }

          if (httpRequest.readyState === 4) {
            if (httpRequest.status === 404 || httpRequest.responseXML === null) {
              throw new Error(isLocal() ? 'Note: SVG injection ajax calls do not work locally without ' + 'adjusting security settings in your browser. Or consider ' + 'using a local webserver.' : 'Unable to load SVG file: ' + url);
            }

            if (httpRequest.status === 200 || isLocal() && httpRequest.status === 0) {
              callback(null, httpRequest);
            } else {
              throw new Error('There was a problem injecting the SVG: ' + httpRequest.status + ' ' + httpRequest.statusText);
            }
          }
        } catch (error) {
          httpRequest.abort();
          callback(error, httpRequest);
        }
      };

      httpRequest.open('GET', url);

      if (httpRequest.overrideMimeType) {
        httpRequest.overrideMimeType('text/xml');
      }

      httpRequest.send();
    };

    var svgCache = new Map();

    var requestQueue = {};
    var queueRequest = function queueRequest(url, callback) {
      requestQueue[url] = requestQueue[url] || [];
      requestQueue[url].push(callback);
    };
    var processRequestQueue = function processRequestQueue(url) {
      var _loop_1 = function _loop_1(i, len) {
        setTimeout(function () {
          if (Array.isArray(requestQueue[url])) {
            var cacheValue = svgCache.get(url);
            var callback = requestQueue[url][i];

            if (cacheValue instanceof SVGElement) {
              callback(null, cloneSvg(cacheValue));
            }

            if (cacheValue instanceof Error) {
              callback(cacheValue);
            }

            if (i === requestQueue[url].length - 1) {
              delete requestQueue[url];
            }
          }
        }, 0);
      };

      for (var i = 0, len = requestQueue[url].length; i < len; i++) {
        _loop_1(i);
      }
    };

    var loadSvgCached = function loadSvgCached(url, callback) {
      if (svgCache.has(url)) {
        var cacheValue = svgCache.get(url);

        if (cacheValue instanceof SVGElement) {
          callback(null, cloneSvg(cacheValue));
          return;
        }

        if (cacheValue instanceof Error) {
          callback(cacheValue);
          return;
        }

        queueRequest(url, callback);
        return;
      }

      svgCache.set(url, undefined);
      queueRequest(url, callback);
      makeAjaxRequest(url, function (error, httpRequest) {
        if (error) {
          svgCache.set(url, error);
        } else if (httpRequest.responseXML instanceof Document && httpRequest.responseXML.documentElement && httpRequest.responseXML.documentElement instanceof SVGElement) {
          svgCache.set(url, httpRequest.responseXML.documentElement);
        }

        processRequestQueue(url);
      });
    };

    var loadSvgUncached = function loadSvgUncached(url, callback) {
      makeAjaxRequest(url, function (error, httpRequest) {
        if (error) {
          callback(error);
        } else if (httpRequest.responseXML instanceof Document && httpRequest.responseXML.documentElement && httpRequest.responseXML.documentElement instanceof SVGElement) {
          callback(null, httpRequest.responseXML.documentElement);
        }
      });
    };

    var idCounter = 0;

    var uniqueId = function uniqueId() {
      return ++idCounter;
    };

    var injectedElements = [];
    var ranScripts = {};
    var svgNamespace = 'http://www.w3.org/2000/svg';
    var xlinkNamespace = 'http://www.w3.org/1999/xlink';

    var injectElement = function injectElement(el, evalScripts, renumerateIRIElements, cacheRequests, beforeEach, callback) {
      var imgUrl = el.getAttribute('data-src') || el.getAttribute('src');

      if (!imgUrl) {
        callback(new Error('Invalid data-src or src attribute'));
        return;
      }

      if (injectedElements.indexOf(el) !== -1) {
        injectedElements.splice(injectedElements.indexOf(el), 1);
        el = null;
        return;
      }

      injectedElements.push(el);
      el.setAttribute('src', '');
      var loadSvg = cacheRequests ? loadSvgCached : loadSvgUncached;
      loadSvg(imgUrl, function (error, svg) {
        if (!svg) {
          injectedElements.splice(injectedElements.indexOf(el), 1);
          el = null;
          callback(error);
          return;
        }

        var imgId = el.getAttribute('id');

        if (imgId) {
          svg.setAttribute('id', imgId);
        }

        var imgTitle = el.getAttribute('title');

        if (imgTitle) {
          svg.setAttribute('title', imgTitle);
        }

        var imgWidth = el.getAttribute('width');

        if (imgWidth) {
          svg.setAttribute('width', imgWidth);
        }

        var imgHeight = el.getAttribute('height');

        if (imgHeight) {
          svg.setAttribute('height', imgHeight);
        }

        var mergedClasses = Array.from(new Set(__spreadArrays((svg.getAttribute('class') || '').split(' '), ['injected-svg'], (el.getAttribute('class') || '').split(' ')))).join(' ').trim();
        svg.setAttribute('class', mergedClasses);
        var imgStyle = el.getAttribute('style');

        if (imgStyle) {
          svg.setAttribute('style', imgStyle);
        }

        svg.setAttribute('data-src', imgUrl);
        var imgData = [].filter.call(el.attributes, function (at) {
          return /^data-\w[\w-]*$/.test(at.name);
        });
        Array.prototype.forEach.call(imgData, function (dataAttr) {
          if (dataAttr.name && dataAttr.value) {
            svg.setAttribute(dataAttr.name, dataAttr.value);
          }
        });

        if (renumerateIRIElements) {
          var iriElementsAndProperties_1 = {
            clipPath: ['clip-path'],
            'color-profile': ['color-profile'],
            cursor: ['cursor'],
            filter: ['filter'],
            linearGradient: ['fill', 'stroke'],
            marker: ['marker', 'marker-start', 'marker-mid', 'marker-end'],
            mask: ['mask'],
            path: [],
            pattern: ['fill', 'stroke'],
            radialGradient: ['fill', 'stroke']
          };
          var element_1;
          var elements_1;
          var properties_1;
          var currentId_1;
          var newId_1;
          Object.keys(iriElementsAndProperties_1).forEach(function (key) {
            element_1 = key;
            properties_1 = iriElementsAndProperties_1[key];
            elements_1 = svg.querySelectorAll(element_1 + '[id]');

            var _loop_1 = function _loop_1(a, elementsLen) {
              currentId_1 = elements_1[a].id;
              newId_1 = currentId_1 + '-' + uniqueId();
              var referencingElements;
              Array.prototype.forEach.call(properties_1, function (property) {
                referencingElements = svg.querySelectorAll('[' + property + '*="' + currentId_1 + '"]');

                for (var b = 0, referencingElementLen = referencingElements.length; b < referencingElementLen; b++) {
                  var attrValue = referencingElements[b].getAttribute(property);

                  if (attrValue && !attrValue.match(new RegExp('url\\("?#' + currentId_1 + '"?\\)'))) {
                    continue;
                  }

                  referencingElements[b].setAttribute(property, 'url(#' + newId_1 + ')');
                }
              });
              var allLinks = svg.querySelectorAll('[*|href]');
              var links = [];

              for (var c = 0, allLinksLen = allLinks.length; c < allLinksLen; c++) {
                var href = allLinks[c].getAttributeNS(xlinkNamespace, 'href');

                if (href && href.toString() === '#' + elements_1[a].id) {
                  links.push(allLinks[c]);
                }
              }

              for (var d = 0, linksLen = links.length; d < linksLen; d++) {
                links[d].setAttributeNS(xlinkNamespace, 'href', '#' + newId_1);
              }

              elements_1[a].id = newId_1;
            };

            for (var a = 0, elementsLen = elements_1.length; a < elementsLen; a++) {
              _loop_1(a);
            }
          });
        }

        svg.removeAttribute('xmlns:a');
        var scripts = svg.querySelectorAll('script');
        var scriptsToEval = [];
        var script;
        var scriptType;

        for (var i = 0, scriptsLen = scripts.length; i < scriptsLen; i++) {
          scriptType = scripts[i].getAttribute('type');

          if (!scriptType || scriptType === 'application/ecmascript' || scriptType === 'application/javascript' || scriptType === 'text/javascript') {
            script = scripts[i].innerText || scripts[i].textContent;

            if (script) {
              scriptsToEval.push(script);
            }

            svg.removeChild(scripts[i]);
          }
        }

        if (scriptsToEval.length > 0 && (evalScripts === 'always' || evalScripts === 'once' && !ranScripts[imgUrl])) {
          for (var l = 0, scriptsToEvalLen = scriptsToEval.length; l < scriptsToEvalLen; l++) {
            new Function(scriptsToEval[l])(window);
          }

          ranScripts[imgUrl] = true;
        }

        var styleTags = svg.querySelectorAll('style');
        Array.prototype.forEach.call(styleTags, function (styleTag) {
          styleTag.textContent += '';
        });
        svg.setAttribute('xmlns', svgNamespace);
        svg.setAttribute('xmlns:xlink', xlinkNamespace);
        beforeEach(svg);

        if (el.parentNode) {
          el.parentNode.replaceChild(svg, el);
        }

        injectedElements.splice(injectedElements.indexOf(el), 1);
        el = null;
        callback(null, svg);
      });
    };

    var SVGInjector = function SVGInjector(elements, _a) {
      var _b = _a === void 0 ? {} : _a,
          _c = _b.afterAll,
          afterAll = _c === void 0 ? function () {
        return undefined;
      } : _c,
          _d = _b.afterEach,
          afterEach = _d === void 0 ? function () {
        return undefined;
      } : _d,
          _e = _b.beforeEach,
          beforeEach = _e === void 0 ? function () {
        return undefined;
      } : _e,
          _f = _b.cacheRequests,
          cacheRequests = _f === void 0 ? true : _f,
          _g = _b.evalScripts,
          evalScripts = _g === void 0 ? 'never' : _g,
          _h = _b.renumerateIRIElements,
          renumerateIRIElements = _h === void 0 ? true : _h;

      if (elements && 'length' in elements) {
        var elementsLoaded_1 = 0;

        for (var i = 0, j = elements.length; i < j; i++) {
          injectElement(elements[i], evalScripts, renumerateIRIElements, cacheRequests, beforeEach, function (error, svg) {
            afterEach(error, svg);

            if (elements && 'length' in elements && elements.length === ++elementsLoaded_1) {
              afterAll(elementsLoaded_1);
            }
          });
        }
      } else if (elements) {
        injectElement(elements, evalScripts, renumerateIRIElements, cacheRequests, beforeEach, function (error, svg) {
          afterEach(error, svg);
          afterAll(1);
          elements = null;
        });
      } else {
        afterAll(0);
      }
    };

    exports.SVGInjector = SVGInjector;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=svg-injector.umd.development.js.map
