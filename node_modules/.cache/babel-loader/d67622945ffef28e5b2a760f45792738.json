{"ast":null,"code":"import { __awaiter, __generator, __values } from \"tslib\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\n\nvar FetchHttpHandler = function () {\n  function FetchHttpHandler(options) {\n    var _this = this;\n\n    if (typeof options === \"function\") {\n      this.configProvider = function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4, options()];\n\n              case 1:\n                return [2, _a.sent() || {}];\n            }\n          });\n        });\n      };\n    } else {\n      this.config = options !== null && options !== void 0 ? options : {};\n    }\n  }\n\n  FetchHttpHandler.prototype.destroy = function () {};\n\n  FetchHttpHandler.prototype.handle = function (request, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        abortSignal = _b.abortSignal;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, requestTimeoutInMs, abortError, path, queryString, port, method, url, body, requestOptions, fetchRequest, raceOfPromises;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!(!this.config && this.configProvider)) return [3, 2];\n            _c = this;\n            return [4, this.configProvider()];\n\n          case 1:\n            _c.config = _d.sent();\n            _d.label = 2;\n\n          case 2:\n            requestTimeoutInMs = this.config.requestTimeout;\n\n            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n              abortError = new Error(\"Request aborted\");\n              abortError.name = \"AbortError\";\n              return [2, Promise.reject(abortError)];\n            }\n\n            path = request.path;\n\n            if (request.query) {\n              queryString = buildQueryString(request.query);\n\n              if (queryString) {\n                path += \"?\".concat(queryString);\n              }\n            }\n\n            port = request.port, method = request.method;\n            url = \"\".concat(request.protocol, \"//\").concat(request.hostname).concat(port ? \":\".concat(port) : \"\").concat(path);\n            body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n            requestOptions = {\n              body: body,\n              headers: new Headers(request.headers),\n              method: method\n            };\n\n            if (typeof AbortController !== \"undefined\") {\n              requestOptions[\"signal\"] = abortSignal;\n            }\n\n            fetchRequest = new Request(url, requestOptions);\n            raceOfPromises = [fetch(fetchRequest).then(function (response) {\n              var e_1, _a;\n\n              var fetchHeaders = response.headers;\n              var transformedHeaders = {};\n\n              try {\n                for (var _b = __values(fetchHeaders.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                  var pair = _c.value;\n                  transformedHeaders[pair[0]] = pair[1];\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n\n              var hasReadableStream = response.body !== undefined;\n\n              if (!hasReadableStream) {\n                return response.blob().then(function (body) {\n                  return {\n                    response: new HttpResponse({\n                      headers: transformedHeaders,\n                      statusCode: response.status,\n                      body: body\n                    })\n                  };\n                });\n              }\n\n              return {\n                response: new HttpResponse({\n                  headers: transformedHeaders,\n                  statusCode: response.status,\n                  body: response.body\n                })\n              };\n            }), requestTimeout(requestTimeoutInMs)];\n\n            if (abortSignal) {\n              raceOfPromises.push(new Promise(function (resolve, reject) {\n                abortSignal.onabort = function () {\n                  var abortError = new Error(\"Request aborted\");\n                  abortError.name = \"AbortError\";\n                  reject(abortError);\n                };\n              }));\n            }\n\n            return [2, Promise.race(raceOfPromises)];\n        }\n      });\n    });\n  };\n\n  return FetchHttpHandler;\n}();\n\nexport { FetchHttpHandler };","map":null,"metadata":{},"sourceType":"module"}