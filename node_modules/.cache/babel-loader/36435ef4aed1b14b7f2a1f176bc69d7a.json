{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nvar SignatureV4 =\n/** @class */\nfunction () {\n  function SignatureV4(_a) {\n    var applyChecksum = _a.applyChecksum,\n        credentials = _a.credentials,\n        region = _a.region,\n        service = _a.service,\n        sha256 = _a.sha256,\n        _b = _a.uriEscapePath,\n        uriEscapePath = _b === void 0 ? true : _b;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath; // default to true if applyChecksum isn't set\n\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  SignatureV4.prototype.presign = function (originalRequest, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, signingDate, _b, expiresIn, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            _a = options.signingDate, signingDate = _a === void 0 ? new Date() : _a, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _l.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _c = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _c = _l.sent();\n            _l.label = 4;\n\n          case 4:\n            region = _c;\n            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n\n            if (expiresIn > MAX_PRESIGNED_TTL) {\n              return [2\n              /*return*/\n              , Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\")];\n            }\n\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request = moveHeadersToQuery(prepareRequest(originalRequest), {\n              unhoistableHeaders: unhoistableHeaders\n            });\n\n            if (credentials.sessionToken) {\n              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n            }\n\n            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n            request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n            _e = request.query;\n            _f = SIGNATURE_QUERY_PARAM;\n            _g = this.getSignature;\n            _h = [longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService)];\n            _j = this.createCanonicalRequest;\n            _k = [request, canonicalHeaders];\n            return [4\n            /*yield*/\n            , getPayloadHash(originalRequest, this.sha256)];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n\n          case 6:\n            _e[_f] = _l.sent();\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.sign = function (toSign, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (typeof toSign === \"string\") {\n          return [2\n          /*return*/\n          , this.signString(toSign, options)];\n        } else if (toSign.headers && toSign.payload) {\n          return [2\n          /*return*/\n          , this.signEvent(toSign, options)];\n        } else {\n          return [2\n          /*return*/\n          , this.signRequest(toSign, options)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  SignatureV4.prototype.signEvent = function (_a, _b) {\n    var headers = _a.headers,\n        payload = _a.payload;\n    var _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        priorSignature = _b.priorSignature,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var region, _d, _e, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _f, stringToSign;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 1];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 2:\n            _d = _g.sent();\n            _g.label = 3;\n\n          case 3:\n            region = _d;\n            _e = formatDate(signingDate), shortDate = _e.shortDate, longDate = _e.longDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            return [4\n            /*yield*/\n            , getPayloadHash({\n              headers: {},\n              body: payload\n            }, this.sha256)];\n\n          case 4:\n            hashedPayload = _g.sent();\n            hash = new this.sha256();\n            hash.update(headers);\n            _f = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 5:\n            hashedHeaders = _f.apply(void 0, [_g.sent()]);\n            stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n            return [2\n            /*return*/\n            , this.signString(stringToSign, {\n              signingDate: signingDate,\n              signingRegion: region,\n              signingService: signingService\n            })];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signString = function (stringToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, shortDate, hash, _e, _f, _g;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _h.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _h.sent();\n            _h.label = 4;\n\n          case 4:\n            region = _d;\n            shortDate = formatDate(signingDate).shortDate;\n            _f = (_e = this.sha256).bind;\n            return [4\n            /*yield*/\n            , this.getSigningKey(credentials, region, shortDate, signingService)];\n\n          case 5:\n            hash = new (_f.apply(_e, [void 0, _h.sent()]))();\n            hash.update(stringToSign);\n            _g = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 6:\n            return [2\n            /*return*/\n            , _g.apply(void 0, [_h.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signableHeaders = _b.signableHeaders,\n        unsignableHeaders = _b.unsignableHeaders,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _f.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _f.sent();\n            _f.label = 4;\n\n          case 4:\n            region = _d;\n            request = prepareRequest(requestToSign);\n            _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request.headers[AMZ_DATE_HEADER] = longDate;\n\n            if (credentials.sessionToken) {\n              request.headers[TOKEN_HEADER] = credentials.sessionToken;\n            }\n\n            return [4\n            /*yield*/\n            , getPayloadHash(request, this.sha256)];\n\n          case 5:\n            payloadHash = _f.sent();\n\n            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n              request.headers[SHA256_HEADER] = payloadHash;\n            }\n\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            return [4\n            /*yield*/\n            , this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n\n          case 6:\n            signature = _f.sent();\n            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + \" \" + (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") + (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") + (\"Signature=\" + signature);\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n    var sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) {\n      return name + \":\" + canonicalHeaders[name];\n    }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n  };\n\n  SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hash, hashedRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            hash = new this.sha256();\n            hash.update(canonicalRequest);\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 1:\n            hashedRequest = _a.sent();\n            return [2\n            /*return*/\n            , ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getCanonicalPath = function (_a) {\n    var path = _a.path;\n\n    if (this.uriEscapePath) {\n      var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  };\n\n  SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stringToSign, hash, _a, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n\n          case 1:\n            stringToSign = _d.sent();\n            _b = (_a = this.sha256).bind;\n            return [4\n            /*yield*/\n            , keyPromise];\n\n          case 2:\n            hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n            hash.update(stringToSign);\n            _c = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _c.apply(void 0, [_d.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  };\n\n  return SignatureV4;\n}();\n\nexport { SignatureV4 };\n\nvar formatDate = function formatDate(now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.substr(0, 8)\n  };\n};\n\nvar getCanonicalHeaderList = function getCanonicalHeaderList(headers) {\n  return Object.keys(headers).sort().join(\";\");\n};\n\nvar normalizeRegionProvider = function normalizeRegionProvider(region) {\n  if (typeof region === \"string\") {\n    var promisified_1 = Promise.resolve(region);\n    return function () {\n      return promisified_1;\n    };\n  } else {\n    return region;\n  }\n};\n\nvar normalizeCredentialsProvider = function normalizeCredentialsProvider(credentials) {\n  if (typeof credentials === \"object\") {\n    var promisified_2 = Promise.resolve(credentials);\n    return function () {\n      return promisified_2;\n    };\n  } else {\n    return credentials;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}