{"ast":null,"code":"'use strict';\n\n(function (fn, name) {\n  if (typeof exports !== \"undefined\") {\n    fn(exports, module);\n  } else if (typeof self !== \"undefined\") {\n    var e = name === \"*\" ? self : name ? self[name] = {} : {};\n    fn(e, {\n      exports: e\n    });\n  }\n})(function (exports, module) {\n  // === Symbol Support ===\n  function hasSymbol(name) {\n    return typeof Symbol === \"function\" && Boolean(Symbol[name]);\n  }\n\n  function getSymbol(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n  } // Ponyfill Symbol.observable for interoperability with other libraries\n\n\n  if (typeof Symbol === \"function\" && !Symbol.observable) {\n    Symbol.observable = Symbol(\"observable\");\n  } // === Abstract Operations ===\n\n\n  function hostReportError(e) {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n\n  function getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n  }\n\n  function getSpecies(obj) {\n    var ctor = obj.constructor;\n\n    if (ctor !== undefined) {\n      ctor = ctor[getSymbol(\"species\")];\n\n      if (ctor === null) {\n        ctor = undefined;\n      }\n    }\n\n    return ctor !== undefined ? ctor : Observable;\n  }\n\n  function addMethods(target, methods) {\n    Object.keys(methods).forEach(function (k) {\n      var desc = Object.getOwnPropertyDescriptor(methods, k);\n      desc.enumerable = false;\n      Object.defineProperty(target, k, desc);\n    });\n  }\n\n  function cleanupSubscription(subscription) {\n    // Assert:  observer._observer is undefined\n    var cleanup = subscription._cleanup;\n    if (!cleanup) return; // Drop the reference to the cleanup function so that we won't call it\n    // more than once\n\n    subscription._cleanup = undefined; // Call the cleanup function\n\n    try {\n      cleanup();\n    } catch (e) {\n      hostReportError(e);\n    }\n  }\n\n  function subscriptionClosed(subscription) {\n    return subscription._observer === undefined;\n  }\n\n  function closeSubscription(subscription) {\n    if (subscriptionClosed(subscription)) return;\n    subscription._observer = undefined;\n    cleanupSubscription(subscription);\n  }\n\n  function cleanupFromSubscription(subscription) {\n    return function () {\n      subscription.unsubscribe();\n    };\n  }\n\n  function Subscription(observer, subscriber) {\n    // Assert: subscriber is callable\n    // The observer must be an object\n    if (Object(observer) !== observer) throw new TypeError(\"Observer must be an object\");\n    this._cleanup = undefined;\n    this._observer = observer;\n\n    try {\n      var start$0 = getMethod(observer, \"start\");\n      if (start$0) start$0.call(observer, this);\n    } catch (e) {\n      hostReportError(e);\n    }\n\n    if (subscriptionClosed(this)) return;\n    observer = new SubscriptionObserver(this);\n\n    try {\n      // Call the subscriber function\n      var cleanup$0 = subscriber.call(undefined, observer); // The return value must be undefined, null, a subscription object, or a function\n\n      if (cleanup$0 != null) {\n        if (typeof cleanup$0.unsubscribe === \"function\") cleanup$0 = cleanupFromSubscription(cleanup$0);else if (typeof cleanup$0 !== \"function\") throw new TypeError(cleanup$0 + \" is not a function\");\n        this._cleanup = cleanup$0;\n      }\n    } catch (e) {\n      // If an error occurs during startup, then attempt to send the error\n      // to the observer\n      observer.error(e);\n      return;\n    } // If the stream is already finished, then perform cleanup\n\n\n    if (subscriptionClosed(this)) cleanupSubscription(this);\n  }\n\n  addMethods(Subscription.prototype = {}, {\n    get closed() {\n      return subscriptionClosed(this);\n    },\n\n    unsubscribe: function unsubscribe() {\n      closeSubscription(this);\n    }\n  });\n\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  addMethods(SubscriptionObserver.prototype = {}, {\n    get closed() {\n      return subscriptionClosed(this._subscription);\n    },\n\n    next: function next(value) {\n      var subscription = this._subscription; // If the stream is closed, then return undefined\n\n      if (subscriptionClosed(subscription)) return;\n      var observer = subscription._observer;\n\n      try {\n        // If the observer has a \"next\" method, send the next value\n        var m$0 = getMethod(observer, \"next\");\n        if (m$0) m$0.call(observer, value);\n      } catch (e) {\n        hostReportError(e);\n      }\n    },\n    error: function error(value) {\n      var subscription = this._subscription; // If the stream is closed, throw the error to the caller\n\n      if (subscriptionClosed(subscription)) {\n        hostReportError(value);\n        return;\n      }\n\n      var observer = subscription._observer;\n      subscription._observer = undefined;\n\n      try {\n        var m$1 = getMethod(observer, \"error\");\n        if (m$1) m$1.call(observer, value);else throw value;\n      } catch (e) {\n        hostReportError(e);\n      }\n\n      cleanupSubscription(subscription);\n    },\n    complete: function complete() {\n      var subscription = this._subscription;\n      if (subscriptionClosed(subscription)) return;\n      var observer = subscription._observer;\n      subscription._observer = undefined;\n\n      try {\n        var m$2 = getMethod(observer, \"complete\");\n        if (m$2) m$2.call(observer);\n      } catch (e) {\n        hostReportError(e);\n      }\n\n      cleanupSubscription(subscription);\n    }\n  });\n\n  function Observable(subscriber) {\n    // Constructor cannot be called as a function\n    if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\"); // The stream subscriber must be a function\n\n    if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n    this._subscriber = subscriber;\n  }\n\n  addMethods(Observable.prototype, {\n    subscribe: function subscribe(observer) {\n      for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) {\n        args.push(arguments[__$0]);\n      }\n\n      if (typeof observer === 'function') {\n        observer = {\n          next: observer,\n          error: args[0],\n          complete: args[1]\n        };\n      } else if (typeof observer !== 'object' || observer === null) {\n        observer = {};\n      }\n\n      return new Subscription(observer, this._subscriber);\n    },\n    forEach: function forEach(fn) {\n      var __this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== \"function\") return Promise.reject(new TypeError(fn + \" is not a function\"));\n\n        __this.subscribe({\n          _subscription: null,\n          start: function start(subscription) {\n            if (Object(subscription) !== subscription) throw new TypeError(subscription + \" is not an object\");\n            this._subscription = subscription;\n          },\n          next: function next(value) {\n            var subscription = this._subscription;\n            if (subscription.closed) return;\n\n            try {\n              fn(value);\n            } catch (err) {\n              reject(err);\n              subscription.unsubscribe();\n            }\n          },\n          error: reject,\n          complete: resolve\n        });\n      });\n    },\n    map: function map(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    },\n    filter: function filter(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    },\n    reduce: function reduce(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            if (!hasValue && !hasSeed) {\n              return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n            }\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  });\n  Object.defineProperty(Observable.prototype, getSymbol(\"observable\"), {\n    value: function value() {\n      return this;\n    },\n    writable: true,\n    configurable: true\n  });\n  addMethods(Observable, {\n    from: function from(x) {\n      var C = typeof this === \"function\" ? this : Observable;\n      if (x == null) throw new TypeError(x + \" is not an object\");\n      var method = getMethod(x, getSymbol(\"observable\"));\n\n      if (method) {\n        var observable$0 = method.call(x);\n        if (Object(observable$0) !== observable$0) throw new TypeError(observable$0 + \" is not an object\");\n        if (observable$0.constructor === C) return observable$0;\n        return new C(function (observer) {\n          return observable$0.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol(\"iterator\") && (method = getMethod(x, getSymbol(\"iterator\")))) {\n        return new C(function (observer) {\n          for (var __$0 = method.call(x)[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) {\n            var item$0 = __$1.value;\n            observer.next(item$0);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          for (var i$0 = 0; i$0 < x.length; ++i$0) {\n            observer.next(x[i$0]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      }\n\n      throw new TypeError(x + \" is not observable\");\n    },\n    of: function of() {\n      for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) {\n        items.push(arguments[__$0]);\n      }\n\n      var C = typeof this === \"function\" ? this : Observable;\n      return new C(function (observer) {\n        for (var i$1 = 0; i$1 < items.length; ++i$1) {\n          observer.next(items[i$1]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    }\n  });\n  Object.defineProperty(Observable, getSymbol(\"species\"), {\n    get: function get() {\n      return this;\n    },\n    configurable: true\n  });\n  Object.defineProperty(Observable, \"extensions\", {\n    value: {\n      observableSymbol: getSymbol(\"observable\"),\n      setHostReportError: function setHostReportError(fn) {\n        hostReportError = fn;\n      }\n    }\n  });\n  exports.Observable = Observable;\n}, \"*\");","map":null,"metadata":{},"sourceType":"script"}